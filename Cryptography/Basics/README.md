# Cryptography Basics

## Symmetric/Private Key Encryption 

Here the data is encrypted using a single key which is known by both the sender and receiver.  Since, both the reciever and sender have access to the same key, it is known as symmetric key encryption. 

:warning: Here data is encrypted and decrypted using the same key. 

### Methods of Symmetric Key Encryption

There are two methods which are used in symmetric key encryption - 

1.  **Stream Cipher**
1.  **Block Cipher**

#### Stream Cipher

The data is encrypted bit-by-bit in stream cipher. It is not much used in modern cryptography.

:warning: ```RC4``` (Rivest Cipher 4) is the most widely used stream cipher. 

#### Block Cipher

Here the data is encrypted in blocks of fixed size. The fixed size can be 64 bit, 128 bit or 256 bit long. 

The data is fed to the algorithm in chunks of fixed size. 

Some examples of Block Cipher are shown below - 

1.  ```DES``` (Data Encryption Standard)
1.  ```Triple DES```
1.  ```IDEA``` (International Data Encryption Algorithm)
1.  ```RC5``` (Rivest Cipher 5)
1.  ```AES``` (Advanced Encryption Standard)
1.  ```Blowfish``` etc. 

### Disadvantage of Symmetric Key Encryption

The symmetric key encryption is simple but it have a major disadvantage. In order for the receiving party to decrypt the message, the sender would somehow have to send the key along with the message. 

Ideally the key should be never shared with anyone. 

If this method of encryption were used in two-way communication and somehow the key lands in wrong hands, both sides of communication will be compromised. 

Public Key Encryption overcomes this disadvantage. 

## Asymmetric/Public Key Encryption 

Here two different keys are used to encrypt and decrypt data. The two keys that are used are as follows - 

1.  Public Key 
1.  Private Key

:warning: The two keys are mathematically related to each other. 

The public key is visible to everyone whereas the private key is present only with the user.

:boom: While using encrypting a message through public key encryption, we need to have access to the public key of the receiver. This is receiver oriented encryption method. 

Let's assume a scenario to better understand the situation. Let us suppose that **Person A** wants to send an encrypted message to **Person B**. In order for the person to do that, he has to have the public key of **Person B**. 

:warning: Public Keys are usually hosted on servers where everyone can access the public key. Here is an [example](https://pgp.mit.edu).

:warning: The public key is meant to be shared with everyone but **not** the private key.

### Credibility of the sender

The public key encryption is more secure than private key encryption but the credibility of the sender is not verifiable. 

To better understand this, let us assume another scenario where **Person A** wants to send a message to **Person B**. In order to do so, **Person A** will access the public key of **Person B** and then encrypt the message. However, since the public key of **Person B** is publicly visible, another entity say  **Person C** might also have access to it. 

Now the **Person C** can impersonate **Person A** and send a message to **Person B**. **Person B** in this case will receive a secure encrypted message but not from the original source. 

In order to avoid such a mishap, digital signatures are used to verfiy the authenticity of the sender. 

## Digital Signatures

Digital Signatures are important and they play a crucial role in verifying the sender. 

Here is an overview of how digital signatures work - 

<p align="center"><img src ="images/digital-sign.png"/></p>

The sender (in this case **Bob**) first generates a ```digest``` of the file by using a hash function. The ```digest``` is then encypted with the primary key of **Bob** to generate the **digital signature**. 

The original file can now also be encrypted using the public key of **Alice**. **Bob** now sends the encrypted file and the ```digest``` to **Alice**. 

When **Alice** receives the two files, she first decryptes the **digital signature** using **Bob's** public key. 

If **Alice** is able to decrypt the **digital signature**, she can conclude that the file is sent from the authentic sender (i.e. **Bob**). 

When **Alice** decryptes the **digital signature**, she gets the ```digest``` of the original file. 

**Alice** can now also decrypt the file sent by **Bob** by using her private key. 

:warning: In asymmetric key encryption, the data is encrypted using the pubilc key of the receiver. 

**Alice** will finally generate a ```digest``` of the decrypted file using a hash function. 

If the ```digest``` generated by **Alice** matches the one generated from the digital signature, we can say the file was not tampered during transit. 

:boom: No two files can have the same hash. It is unique for each file. There are different types of hashing algorithms. 

## How hash functions work?

