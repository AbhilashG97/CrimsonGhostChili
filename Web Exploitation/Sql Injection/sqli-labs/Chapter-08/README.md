# Chapter-08

This section will deal with challenges based on cookies. 

## What are cookies?

> An HTTP cookie (also called web cookie, Internet cookie, browser cookie, or simply cookie) is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing.

Wikipedia has an awesome [post](https://en.wikipedia.org/wiki/HTTP_cookie) on cookies.

## Exploiting cookies : lesson-20 and lesson-21

Lesson-20 is a simple challenge where the cookie value changes depending on who logs in to the website. 

This makes the cookie vulnerable. 

The cookie can be exploited by setting the below mentioned value - 

```sql 
' union select group_concat(username), group_concat(password), 3 from users #
```

:warning: The query breaks when ```\``` is set as a value to the cookie. 

Lesson-21 is exactly similar to lesson-21 with the only difference being that in lesson-21, the cookie value is base64 encoded. Therefore, to exploit the cookie, the payload will also have to be base64 encoded which will look somewhat like this - 

```
JykgdW5pb24gc2VsZWN0IGdyb3VwX2NvbmNhdCh1c2VybmFtZSksIGdyb3VwX2NvbmNhdChwYXNzd29yZCksIDMgZnJvbSB1c2VycyAj
```

## Lesson 22

This challenge is quite similar to challenge 21. 

Here the information present in the cookie is directly fed to the sql query without sanitizing the input. 

The input fields however are well protected. The inputs of the input fields are sanitized before feeding it to the sql query. 

The cookie is set after the user logs-in. The information shown after the user logs-in is taken from the cookie. 

The username is stored in the cookie after the user logs-in. Then the username stored in the cookie is used to display the information on the webpage. Since, the username is used directly without performing any checks, we can exploit the cookie value to perform a sql injection. 

The cookie value is ```base64``` encoded which can be easily decoded. 

The payload is shown below -

```sql
-admin" union select group_concat(id), group_concat(username), group_concat(password) from users limit 0, 1 #
```

The above payload now needs to be ```base64``` encoded and set in the cookie value.

## Lesson 23

This is a simple challenge that can be solved with Blind SQL Injection. 

The comments are being stripped off which makes it difficult to perform direct sql injection. 

We can try balancing the query with ```AND```, ```OR``` and appropriate quotes. This technique works well for this challenge. The url for the same can be found below - 

```
http://localhost/sqlilabs/Less-23/?id=1' and '1
```

But now we cannot use ```from``` clause. This leaves us with two options - 

1.  Double Query Injection
1.  Blind SQL Injection

If we try to break the query, we will realize that the webpage does not show any error messages when the sql query is broken. Hence, ```Double Query Injection``` cannot be used in this case. 

We are now left with the option of using ```Blind SQL Injection```. We can automate the process of performing the ```Blind SQL Injection``` by making use of a python script. 

The script can be found [here](#).

We now just have to run the script and change the payload according to the results that we get. On enumerating the payload we can get all the usernames and passwords. 

The payload can be found below - 

```sql 
select (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1), 1, 1)) = 101);
```

## Second Order injections

> SQL injection vulnerabilities arise when user-controllable data is incorporated into database SQL queries in an unsafe manner. An attacker can supply crafted input to break out of the data context in which their input appears and interfere with the structure of the surrounding query.

In second order injections, the user will not be able to perfrom a direct injection but will be able to run a macilious query indirectly. This can be done a passing a malicious query that gets stored in the database and is executed later on. 

For this reason, a developer should always sanitize the input before executing them in a query. 

## Lesson 24

This challenge is based on ```Second Order SQL Injections```. 

The aim of this challenge is to change the credentials of a different user and log-in into their account. 

In order to accomplish this, we need to find an existing user. This can be done by going to the ```New User Page```. We can try different usernames. If a username already exists, we are greeted with an alert that says ```User Exists```.

In the case of this challenge, one such user is ```admin```.

Now, we will inject a malicious username into the database by creating a new user. 

The username of the new user will be - 

```admin' #```

Now, we can log-in as ```admin' #```.

We will now proceed to reset the password of ```admin' #```. But instead we end up changing the password of ```admin```. 

This can be better understood if we look at the following query - 

```sql
UPDATE users SET PASSWORD='$new_pass' where username='$username' and password='$curr_pass';
```

The above query gets executed when we try to reset the password of the current user. 

Note that, in our case, the current user is ```admin' #```. 

When this username is passed to the query, the query is modified to something like this - 

```sql
UPDATE users SET PASSWORD='$new_pass' where username='admin' #' and password='$curr_pass';
```

The above query will now proceed to change the password of ```admin``` and not ```admin' #```. 

Now, we can log-in as ```admin``` with the password of our choice.  